<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>英桥在干什么吖</title>
    <link>https://yingqiao1998.github.io/</link>
    <description>Recent content on 英桥在干什么吖</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 31 Mar 2023 08:55:12 +0800</lastBuildDate><atom:link href="https://yingqiao1998.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>入门和概念</title>
      <link>https://yingqiao1998.github.io/posts/linuxsystemprograming/%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
      <pubDate>Fri, 31 Mar 2023 08:55:12 +0800</pubDate>
      
      <guid>https://yingqiao1998.github.io/posts/linuxsystemprograming/%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
      <description>系统编程的基础 Linux系统编程有伞大基石：系统调用、C库和C编译器。
系统调用 （syscall） 系统编程始于系统调用，也终于系统调用。系统调用（通常简称为syscall）是为了从操作系统请求一些服务或资源，是从用户空间如文本编辑器、游戏等向内核（系统的核心）发起的函数调用。
Linux实现的系统调用远远少于其他内核。举例来说，微软的Windows，其系统调用号称有几千个，而Linux x86-64体系结构的系统调用大概只有300个。在Linux内核中，每种体系结构（Alpha、x86-64或PowerPC）各自实现了标准系统调用。因此，不同体系结构支持的系统调用可能存在区别。然而，超过90%的系统调用在所有的体系结构上都实现了。
位于用户空间的应用程序无法直接访问内核空间，内核必须提供一种机制当用户空间的应用希望执行系统调用的时候，可以通过该机制通知内核。
虽然基本思想是一致的，但不同体系结构处理系统调用的方式不同。作为一名系统程序员，通常不需要了解内核是如何处理系统调用的。系统调用已经集成到各种体系结构的标准调用规范中，并通过编译器和C库自动处理。
C库 C库（libc）是UNIX应用程序的核心。即使你是使用其他语言编程，通常还是会通过高级语言封装的C库来提供核心服务，以方便系统调用。在现代Linux系统中，C库由GNU libc提供，简称glibc，发音是[gee-lib-see]，或者有时发作[glib-see]。
GNU C库的功能远远超出了其名字的范畴。glibc中，除了标准C库，还提供了系统调用封装、线程支持和基本应用工具。
C编译器 在Linux中，标准C编译器是由GNU编译器工具集（GNU Compiler Collection，gcc）提供的。最初，gcc是GNU版的C编译器cc，因此，gcc表示GNU C编译器（GNU C Compiler）。随着时间推移，gcc支持越来越多的语言。时至今日，gcc已经成了GNU编译器家族的代名词。此外，gcc还表示C编译器二进制程序。除非特别指明，本书中提到gcc时，都是指gcc应用程序。
API和ABI 在系统层，有两组独立的影响可移植性的定义和描述。一是应用程序编程接口（Application Programming Interface，API），二是应用程序二进制接口（Application Binary Interface，ABI），它们都是用来定义和描述计算机软件的不同模块间的接口的。
API “API定义了软件模块之间在源代码层交互的接口。它提供一组标准的接口（通常以函数的方式）实现了如下抽象：一个软件模块（通常是较高层的代码）如何调用另一个软件模块（通常位于较低层）。举个例子，API可以通过一组绘制文本函数，对在屏幕上绘制文本的概念进行抽象。API仅仅是定义接口，真正提供API的软件模块称为API的实现。 通常，人们把API称为“约定”，这并不合理，至少从API这个术语角度来讲，它并非一个双向协议。API用户（通常是高级软件）并没有对API及其实现提供任何贡献。API用户可以使用API，也可以完全不用它：用或不用，仅此而已！API的职能只是保证如果两个软件模块都遵循API，那么它们是“源码兼容”（source compatible），也就是说，不管API如何实现，API用户都能够成功编译。 API的一个实际例子就是由C标准定义的接口，通过标准C库实现。该API定义了一组基础函数，比如内存管理和字符串处理函数。
ABI API定义了源码接口，而ABI定义了两个软件模块在特定体系结构上的二进制接口。它定义了应用内部如何交互，应用如何与内核交互，以及如何和库交互。API保证了源码兼容，而ABI保证了“二进制兼容（binary compatibility）”，确保对于同一个ABI，目标代码可以在任何系统上正常工作，而不需要重新编译。 ABI主要关注调用约定、字节序、寄存器使用、系统调用、链接、库的行为以及二进制目标格式。例如，调用约定定义了函数如何调用，参数如何传递，分别保留和使用哪些寄存器，调用方如何获取返回值。
文件和文件系统 文件打开方式有只读、只写和读写模式。
文件描述符（file descriptor）：
Linux中用一个整数表示文件 文件描述符在用户空间共享 普通文件 普通文件包含以字节流组织的数据。
在Linux中，可以从文件中的任意字节开始读写。对文件的操作是从某个字节开始，即文件“地址”。该地址称为文件位置（file location）或文件偏移（file offset）。文件位置是内核中与每个打开的文件关联的元数据中很重要的一项。第一次打开文件时，其偏移为0。通常，随着按字节对文件的读写，文件偏移也随之增加。文件偏移还可以手工设置成给定值，该值甚至可以超出文件结尾。在文件结尾后面追加一个字节会使得中间字节都被填充为0。虽然支持通过这种在文件末尾追加字节的操作，但是不允许在文件的起始位置之前写入字节。这种操作看起来就很荒谬，实际上也并无用处。文件位置的起始值为0，不能是负数。在文件中间位置写入字节会覆盖该位置原来的数据。因此，在中间写入数据并不会导致原始数据向后偏移。绝大多数文件写操作都是发生在文件结尾。
同一个文件可以由多个进程或同一个进程多次打开。系统会为每个打开的文件实例提供唯一文件描述符。因此，进程可以共享文件描述符，支持多个进程使用同一个文件描述符。Linux内核没有限制文件的并发访问。不同的进程可以同时读写同一个文件。对文件并发访问的结果取决于这些操作的顺序，通常是不可预测的。用户空间的程序往往需要自己协调，确保对文件的同步访问是合理的。
文件虽然是通过文件名访问，但文件本身其实并没有直接和文件名关联。相反地，与文件关联的是索引节点inode（最初称为信息节点 ，是information node的缩写），inode是文件系统为该文件分配的唯一整数值（但是在整个系统中不一定是唯一的）。该整数值称为inode number，通常简称为i-number或ino。索引节点中会保存和文件相关的元数据，如文件修改时间戳、所有者、类型、长度以及文件数据的位置——但不含文件名！索引节点就是UNIX文件在磁盘上的实际物理对象，也是在Linux内核中通过数据结构表示的概念实体。
目录和链接 目录用于提供访问文件需要的名称。目录是可读名称到索引编号之间的映射。名称和索引节点之间的配对称为链接（link）。映射在物理磁盘上的形式，如简单的表或散列，是通过特定文件系统的内核代码来实现和管理的。从概念上看，可以把目录看作普通文件，其区别在于它包含文件名称到索引节点的映射。内核直接通过该映射把文件名解析为索引节点。
硬链接 每个索引节点包含链接计数（link count），记录该索引节点在文件系统中的链接数。当unlink某个路径时，其链接计数会减1；只有当链接计数为0时，索引节点及其关联的数据才会从文件系统中真正删除。
符号链接 符号链接类似于普通文件，每个符号链接有自己的索引节点和数据块，包含要链接的文件的绝对路径。这意味着符号链接可以指向任何地方，包括不同的文件系统上的文件和路径，甚至指向不存在的文件和目录。指向不存在的文件的符号链接称为坏链接（broken link）。 比起硬链接，符号链接会带来更多的开销，因为有效解析符号链接需要解析两个文件：一是符号链接本身，二是该链接所指向的文件。硬链接不会带来这些额外开销——因为访问在文件系统中被多次链接的文件和单次链接的文件没有区别。虽然符号链接的开销很小，但还是被认为是个负面因素。
特殊文件 是指以文件来表示的内核对象。
“Linux只支持四种特殊文件：块设备文件、字符设备文件、命名管道以及UNIX域套接字。特殊文件是使得某些抽象可以适用于文件系统，贯彻一切皆文件的理念。Linux提供了系统调用来创建特殊文件。 在UNIX系统中，访问设备是通过设备文件来实现，把设备当作文件系统中的普通文件。设备文件支持打开、读和写操作，允许用户空间程序访问和控制系统上的（物理和虚拟）设备。UNIX设备通常可以划分成两组：字符设备（character devices）和块设备（block device）。每种设备都有自己的特殊文件。 字符设备是作为线性字节队列来访问。设备驱动程序把字节按顺序写入队列，用户空间程序按照写入队列的顺序读取数据。键盘就是典型的字符设备。举个例子，当用户输入“peg”，应用程序将顺序从键盘设备中读取p、e和g。如果没有更多的字符读取时，设备会返回end-of-file（EOF）。漏读数据或以其他顺序读取都是不可能的。字符设备通过字符设备文件（character device file）进行访问。 和字符设备不同，块设备是作为字节数组来访问。设备驱动把字节映射到可寻址的设备上，用户空间可以按任意顺序随意访问数组中的任何字节——可能读取字节12，然后读取字节7，然后又读取字节12。块设备通常是存储设备。硬盘、软盘、CD-ROM驱动和闪存都是典型的块设备。这些块设备通过块设备文件（block device file）来访问。 命名管道（named pipes），通常称为FIFO（是“先进先出first in, first out”的简称），是以文件描述符作为通信信道的进程间通信（IPC）机制，它可以通过特殊文件来访问。普通管道是将一个程序的输出以“管道”形式作为另一个程序的输入，普通管道是通过系统调用在内存中创建的，并不存在于任何文件系统中。命名管道和普通管道一样，但其是通过FIFO特殊文件访问，不相关进程可以访问该文件并进行交互。</description>
    </item>
    
  </channel>
</rss>
